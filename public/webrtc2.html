<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebRTC Clean View</title>
  <style>
    body { 
      margin: 0; 
      padding: 0; 
      background: #000; 
      color: #fff; 
      font: 14px system-ui, -apple-system, sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    #controls {
      padding: 8px;
      display: flex;
      gap: 8px;
      align-items: center;
      background: #111;
      border-bottom: 1px solid #333;
    }
    button {
      padding: 6px 12px;
      border-radius: 4px;
      border: 1px solid #333;
      background: #1a1a1a;
      color: #fff;
      cursor: pointer;
    }
    button:hover { background: #2a2a2a; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    #video-container {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
    }
    #video {
      display: block;
      cursor: crosshair;
    }
    #info {
      position: absolute;
      top: 8px;
      right: 8px;
      background: rgba(0,0,0,0.8);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <div id="controls">
    <button id="connectBtn">Connect</button>
    <button id="clickBtn" disabled>Click Mode: Off</button>
    <span id="status">Disconnected</span>
  </div>
  <div id="video-container">
    <video id="video" autoplay playsinline muted></video>
    <div id="info"></div>
  </div>
  
  <script>
    const video = document.getElementById('video');
    const status = document.getElementById('status');
    const info = document.getElementById('info');
    const connectBtn = document.getElementById('connectBtn');
    const clickBtn = document.getElementById('clickBtn');
    const videoContainer = document.getElementById('video-container');
    
    // Optional bottom crop (in CSS pixels) to remove letterboxing while preserving click accuracy
    const params = new URLSearchParams(location.search);
    let cropBottom = Math.max(0, Math.floor(Number(params.get('crop') || params.get('cropBottom') || 0)) || 0);
    
    let pc = null;
    let dc = null;
    let clickMode = false;
    let streamDimensions = null;
    let fps = 0;
    let fpsCount = 0;
    let fpsLastTs = 0;
    
    // Simple WebSocket for clicks
    let ws = null;
    function connectWS() {
      try {
        ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host);
        ws.onopen = () => console.log('WS connected');
        ws.onclose = () => setTimeout(connectWS, 1000);
      } catch (e) { console.warn('WS error', e); }
    }
    
    clickBtn.onclick = () => {
      clickMode = !clickMode;
      clickBtn.textContent = 'Click Mode: ' + (clickMode ? 'On' : 'Off');
      video.style.cursor = clickMode ? 'pointer' : 'crosshair';
    };
    
    function sendClick(vx, vy) {
      // Prefer DataChannel, then WS, then HTTP fallback
      try {
        if (dc && dc.readyState === 'open') {
          dc.send(JSON.stringify({ type: 'CLICK_VIEWPORT', vx, vy }));
          return;
        }
      } catch {}
      try {
        if (ws && ws.readyState === 1) {
          ws.send(JSON.stringify({ type: 'CLICK_VIEWPORT', vx, vy }));
          return;
        }
      } catch {}
      // Last resort: HTTP POST
      fetch('/webrtc2/click', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ vx, vy })
      }).catch(()=>{});
    }

    // Click catcher overlay sized to the visible area (after cropping)
    const hitbox = document.createElement('div');
    hitbox.style.cssText = 'position:absolute;left:50%;transform:translateX(-50%);top:0;pointer-events:auto;';
    videoContainer.appendChild(hitbox);
    
    function layoutVideo() {
      if (!streamDimensions) return;
      const w = streamDimensions.width;
      const h = streamDimensions.height;
      const visibleH = Math.max(0, h - cropBottom);
      // Size the video to its full native streaming size; hide bottom via container overflow
      video.style.width = w + 'px';
      video.style.height = h + 'px';
      // Constrain container height to visible portion only
      videoContainer.style.overflow = 'hidden';
      videoContainer.style.height = visibleH + 'px';
      // Center the video; we already have display:flex/center; position for overlay
      hitbox.style.width = w + 'px';
      hitbox.style.height = visibleH + 'px';
      updateInfo();
    }

    function updateInfo() {
      if (!streamDimensions) return;
      const dims = `${streamDimensions.width}Ã—${streamDimensions.height}`;
      const fpsText = fps ? ` @ ${fps.toFixed(0)} fps` : '';
      info.textContent = `${dims}${cropBottom?` (crop ${cropBottom}px)`:''}${fpsText}`;
    }

    hitbox.addEventListener('click', (e) => {
      if (!clickMode || !streamDimensions) return;
      const rect = hitbox.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      // Map to original viewport coordinates. Visible height excludes bottom crop, so vy maps 1:1 to top portion.
      const vx = Math.floor((x / rect.width) * streamDimensions.width);
      const vy = Math.floor((y / rect.height) * (streamDimensions.height - cropBottom));
      
      console.log('Click at', vx, vy);
      
      sendClick(vx, vy);
    });
    
    async function connect() {
      try {
        status.textContent = 'Connecting...';
        connectBtn.disabled = true;
        
        // Get ICE servers
        const configRes = await fetch('/webrtc2/config');
        const config = await configRes.json();
        
        // Create peer connection
        pc = new RTCPeerConnection({ 
          iceServers: config.iceServers || [{ urls: 'stun:stun.l.google.com:19302' }] 
        });
        
        // Handle incoming video
        pc.ontrack = (e) => {
          console.log('Got track', e.track.kind);
          if (e.track.kind === 'video') {
            video.srcObject = e.streams[0];
            status.textContent = 'Connected';
            clickBtn.disabled = false;
          }
        };

        // Create control DataChannel (server listens via ondatachannel)
        dc = pc.createDataChannel('control');
        dc.onopen = () => console.log('DC open');
        dc.onclose = () => console.log('DC close');
        dc.onerror = (e) => console.warn('DC error', e);
        dc.onmessage = (e) => { try { const j = JSON.parse(e.data); console.log('DC msg', j); } catch { console.log('DC msg', e.data); } };
        
        // Monitor connection
        pc.onconnectionstatechange = () => {
          status.textContent = pc.connectionState;
          if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
            connectBtn.disabled = false;
          }
        };
        
        // Request video
        pc.addTransceiver('video', { direction: 'recvonly' });
        
        // Create and send offer
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        
        // Wait for ICE gathering
        await new Promise(r => {
          if (pc.iceGatheringState === 'complete') r();
          else pc.onicegatheringstatechange = () => {
            if (pc.iceGatheringState === 'complete') r();
          };
        });
        
        // Send offer to server
        const response = await fetch('/webrtc2/offer', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ offer: pc.localDescription })
        });
        
        const data = await response.json();
        if (!data.answer) throw new Error('No answer received');
        
        // Store dimensions
        if (data.dimensions) {
          streamDimensions = data.dimensions;
          updateInfo();
          layoutVideo();
        }
        
        await pc.setRemoteDescription(data.answer);
        
        // Connect WebSocket for interaction (fallback/control)
        connectWS();
        
      } catch (err) {
        console.error('Connection error:', err);
        status.textContent = 'Error: ' + err.message;
        connectBtn.disabled = false;
      }
    }
    
    connectBtn.onclick = connect;
    
    // Monitor video metadata
    video.onloadedmetadata = () => {
      console.log('Video dimensions:', video.videoWidth, 'x', video.videoHeight);
      if (!streamDimensions) {
        streamDimensions = { width: video.videoWidth, height: video.videoHeight };
        updateInfo();
        layoutVideo();
      }
      // Start FPS meter
      fpsCount = 0;
      fpsLastTs = performance.now();
      if (typeof video.requestVideoFrameCallback === 'function') {
        const step = (_now, _metadata) => {
          fpsCount++;
          const now = performance.now();
          const dt = now - fpsLastTs;
          if (dt >= 1000) {
            fps = (fpsCount * 1000) / dt;
            fpsCount = 0;
            fpsLastTs = now;
            updateInfo();
          }
          try { video.requestVideoFrameCallback(step); } catch {}
        };
        try { video.requestVideoFrameCallback(step); } catch {}
      } else {
        // Fallback: estimate via setInterval
        setInterval(() => {
          fps = fps * 0.6 + (fpsCount * 0.4);
          fpsCount = 0;
          updateInfo();
        }, 1000);
        const paint = () => { fpsCount++; requestAnimationFrame(paint); };
        requestAnimationFrame(paint);
      }
    };

    // Reflect click mode cursor on hitbox
    function updateCursor() {
      hitbox.style.cursor = clickMode ? 'pointer' : 'crosshair';
    }
    updateCursor();
    clickBtn.addEventListener('click', updateCursor);
  </script>
</body>
</html>
