<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>No Planner (Exact-Match)</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:#0f1222; color:#eaeef9; margin:0; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 16px; }
    h1 { margin: 0 0 12px; font-size: 18px; }
    .row { display:flex; gap:8px; align-items:center; margin:6px 0; flex-wrap: wrap; }
    input, button, textarea { padding:8px; border-radius:6px; border:1px solid #334; background:#161b38; color:#dbe3ff; }
    textarea { width:100%; min-height:100px; }
    button { background:#2a3cff; border-color:#2a3cff; cursor:pointer; }
    button:hover { filter:brightness(1.1); }
    pre { background:#0b0e1a; border:1px solid #334; border-radius:6px; padding:8px; overflow:auto; }
    pre.fixed { width:100%; max-width:100%; box-sizing:border-box; white-space: pre-wrap; word-break: break-word; overflow-wrap:anywhere; }
    .cols { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    .hint { opacity:.8; font-size:12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>No Planner (Exact-Match) — Screen-first Runner</h1>
    <div class="row">
      <span class="hint">Current URL</span>
      <input id="currentUrlLine" type="text" readonly style="flex:1; background:#0b0e1a; border:1px solid #334; padding:6px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, monospace;" />
      <button id="btnCopyUrl">Copy</button>
    </div>
    <div class="row">
      <input id="openaiKey2" type="password" placeholder="OpenAI API key (Nano)" style="width:280px" />
      <input id="assistantId2" type="text" placeholder="Assistant ID (Nano)" style="width:280px" />
      <button id="btnSave">Save</button>
      <span id="saveMsg"></span>
    </div>
    <div class="row">
      <input id="prompt" type="text" placeholder="Goal (e.g., Find Chipotle and open its page)" style="flex:1" />
      <button id="btnRun">Run (no planner, exact-match)</button>
      <button id="btnFocus">Focus Browser</button>
    </div>
    <div class="row">
      <input id="url" type="url" placeholder="Optional start URL (e.g., https://www.ubereats.com/)" style="flex:1" />
      <button id="btnGo">Go</button>
    </div>
    <div class="row">
      <button id="btnServerIp">Server IP</button>
      <button id="btnBrowserIp">Browser IP</button>
      <span id="ipOut" class="hint"></span>
    </div>

    <!-- Pause, add context, and continue controls -->
    <div class="row">
      <textarea id="contextNotes" placeholder="Add context/instructions to help the run (e.g., 'Log in with test user', 'We are already authenticated', 'Skip promo modal')."></textarea>
    </div>
    <div class="row">
      <button id="btnPause">Pause</button>
      <button id="btnContinue" disabled>Continue with context</button>
      <button id="btnClearContext" class="hint">Clear context</button>
      <span id="pauseMsg" class="hint" style="margin-left:auto;"></span>
    </div>

    <div class="cols">
      <div>
        <h3>Critic Input</h3>
        <pre id="criticInput" class="fixed" style="height:180px; max-height:180px; width:100%; overflow:auto;"></pre>
      </div>
      <div>
        <h3>Critic Output</h3>
        <pre id="criticOutput" class="fixed" style="height:180px; max-height:180px; width:100%; overflow:auto;"></pre>
      </div>
    </div>

    <div class="cols">
      <div>
        <h3>Critic Screenshot</h3>
        <div id="criticShotBox" style="background:#0b0e1a; border:1px solid #334; border-radius:6px; padding:8px; height:240px; max-height:240px; width:100%; overflow:auto; display:flex; align-items:center; justify-content:center;">
          <img id="criticShot" alt="critic screenshot" style="max-width:100%; max-height:220px; object-fit:contain;" />
        </div>
      </div>
      <div>
        <h3>Complete History</h3>
        <pre id="completeHistory" class="fixed" style="height:240px; max-height:240px; width:100%; overflow:auto;"></pre>
      </div>
    </div>

    <div class="cols">
      <div>
      <h3>STEP3 (full hittables in radius)</h3>
      <pre id="step3" class="fixed" style="height:180px; max-height:180px; width:100%; overflow:auto;"></pre>
      </div>
      <div>
      <h3>Exact Match Click</h3>
      <pre id="exact" class="fixed" style="height:80px; max-height:80px; width:100%; overflow:auto;"></pre>
      </div>
    </div>

  <div class="cols">
    <div>
      <h3>Step 4 Output (Assistant 2 decision)</h3>
      <pre id="step4" class="fixed" style="height:180px; max-height:180px; width:100%; overflow:auto;"></pre>
    </div>
    <div>
      <h3>Step 4 Text</h3>
      <pre id="step4Text" class="fixed" style="height:180px; max-height:180px; width:100%; overflow:auto;"></pre>
    </div>
  </div>
  <div class="cols">
    <div>
      <h3>Verification</h3>
      <pre id="verification" class="fixed" style="height:140px; max-height:140px; width:100%; overflow:auto;"></pre>
    </div>
    <div>
      <h3>Scrolls</h3>
      <pre id="scrolls" class="fixed" style="height:140px; max-height:140px; width:100%; overflow:auto;"></pre>
    </div>
  </div>
  </div>

  <script>
    // Cross-tab channel to sync with /ui
    const bc = (()=>{ try { return new BroadcastChannel('webagent_run'); } catch { return null; } })();
    const logEl = document.getElementById('log');
    function log(msg){ try { const t = new Date().toLocaleTimeString(); logEl.textContent = `[${t}] ${msg}\n` + logEl.textContent; } catch {} }

    const backend = {
      remoteEnabled: localStorage.getItem('remoteEnabled') === 'true',
      baseHttp: (localStorage.getItem('remoteHttp') || '').trim(),
      wsUrl: (localStorage.getItem('remoteWs') || '').trim(),
      machineId: (localStorage.getItem('remoteMachineId') || '').trim(),
      machineHost: (localStorage.getItem('remoteMachineHost') || '').trim(),
      directWs: (localStorage.getItem('remoteDirectWs') || '').trim(),
      signaling: (() => { try { const raw = localStorage.getItem('remoteSignaling'); return raw ? JSON.parse(raw) : null; } catch { return null; } })(),
      iceServers: (() => { try { const raw = localStorage.getItem('remoteIceServers'); return raw ? JSON.parse(raw) : null; } catch { return null; } })()
    };
    let signalingUrl = backend.signaling && backend.signaling.url ? backend.signaling.url : (localStorage.getItem('viewerSignalUrl') || '');
    let signalToken = backend.signaling && backend.signaling.token ? backend.signaling.token : (localStorage.getItem('viewerSignalToken') || '');
    if (!backend.baseHttp) backend.baseHttp = location.origin;
    if (!backend.wsUrl) backend.wsUrl = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host;

    function backendFetch(path, opts) {
      const aggregator = String(backend.baseHttp || location.origin).replace(/\/$/, '');
      const directHttp = backend.machineHost ? String(backend.machineHost).replace(/\/$/, '') : '';
      const altFromWs = backend.directWs ? backend.directWs.replace(/^wss:\/\//, 'https://').replace(/^ws:\/\//, 'http://').replace(/\/$/, '') : '';
      const base = aggregator || directHttp || altFromWs;
      const p = String(path || '');
      const hasQuery = p.includes('?');
      const useFlyHeader = (!!aggregator && base === aggregator && backend.machineId);
      const machineParam = useFlyHeader ? `${hasQuery ? '&' : '?'}fly_machine=${backend.machineId}` : '';
      const url = base + p + machineParam;
      const headers = new Headers((opts && opts.headers) || {});
      if (useFlyHeader) headers.set('Fly-Machine', backend.machineId);
      const init = opts ? { ...opts } : {};
      init.headers = headers;
      try { log(`[fetch] base=${base} flyHeader=${useFlyHeader}`); } catch {}
      return fetch(url, init);
    }

    let signalWs = null;
    let signalReady = false;
    const signalQueue = [];
    const signalPending = new Map();
    let signalCounter = 0;

    function resetSignalSocket(){
      signalReady = false;
      try { if (signalWs) signalWs.close(); } catch {}
      signalWs = null;
      for (const [, reject] of signalPending.values()) {
        try { reject(new Error('signal_connection_reset')); } catch {}
      }
      signalPending.clear();
    }

    function ensureSignalSocket(){
      if (!signalingUrl || !signalToken) return null;
      if (signalWs && (signalWs.readyState === WebSocket.OPEN || signalWs.readyState === WebSocket.CONNECTING)) {
        return signalWs;
      }
      resetSignalSocket();
      try {
        const target = `${signalingUrl}${signalingUrl.includes('?') ? '&' : '?'}token=${encodeURIComponent(signalToken)}`;
        signalWs = new WebSocket(target);
      } catch (err) {
        console.warn('[signal] ws create error', err && err.message || err);
        return null;
      }
      signalWs.addEventListener('open', () => { signalReady = false; });
      signalWs.addEventListener('message', (ev) => {
        let msg;
        try { msg = JSON.parse(ev.data); } catch { return; }
        if (msg.type === 'ready') {
          signalReady = true;
          while (signalQueue.length) {
            try { signalWs.send(JSON.stringify(signalQueue.shift())); } catch {}
          }
          return;
        }
        if (msg.type === 'pong') return;
        if (msg.type === 'response' && msg.id) {
          const pending = signalPending.get(msg.id);
          if (pending) {
            signalPending.delete(msg.id);
            const { resolve, reject } = pending;
            if (msg.ok) resolve(msg);
            else {
              const err = new Error(msg.error || 'signal_error');
              err.status = msg.status;
              reject(err);
            }
          }
        }
      });
      signalWs.addEventListener('close', () => {
        signalReady = false;
        for (const [, reject] of signalPending.values()) {
          try { reject(new Error('signal_connection_closed')); } catch {}
        }
        signalPending.clear();
      });
      signalWs.addEventListener('error', (err) => {
        console.warn('[signal] ws error', err && err.message || err);
      });
      return signalWs;
    }

    function ensureSignalReady(){
      return new Promise((resolve, reject) => {
        const ws = ensureSignalSocket();
        if (!ws) {
          reject(new Error('signal_not_configured'));
          return;
        }
        if (signalReady && ws.readyState === WebSocket.OPEN) {
          resolve(ws);
          return;
        }
        const check = () => {
          if (signalReady && ws.readyState === WebSocket.OPEN) {
            resolve(ws);
            return;
          }
          if (ws.readyState === WebSocket.CLOSED || ws.readyState === WebSocket.CLOSING) {
            reject(new Error('signal_connection_failed'));
            return;
          }
          setTimeout(check, 50);
        };
        setTimeout(check, 10);
      });
    }

    async function signalRequest(method, path, body, headers){
      const ws = await ensureSignalReady();
      const id = `req-${Date.now()}-${++signalCounter}`;
      const payload = { id, type: 'request', method, path, body, headers };
      return new Promise((resolve, reject) => {
        signalPending.set(id, { resolve, reject });
        const msg = JSON.stringify(payload);
        if (signalReady && ws.readyState === WebSocket.OPEN) {
          try { ws.send(msg); } catch (err) { signalPending.delete(id); reject(err); }
        } else {
          signalQueue.push(payload);
        }
        setTimeout(() => {
          if (signalPending.has(id)) {
            signalPending.delete(id);
            reject(new Error('signal_timeout'));
          }
        }, 10000);
      });
    }

    let ws = null;
    let wsReady = false;
    const wsQueue = [];
    function onWsMessage(ev){
      try {
        const m = JSON.parse(ev.data);
        if (m && m.type === 'NAVIGATED' && typeof m.url === 'string') setUrlBar(m.url);
        if (m && m.type === 'URL' && typeof m.url === 'string') setUrlBar(m.url);
        if (m && m.type === 'SERVER_IP') { try { document.getElementById('ipOut').textContent = m.ok ? `server ${m.ip || 'n/a'} (${(m.env&&m.env.fly&&m.env.fly.region)||'?'})` : `server error: ${m.error}`; } catch {} }
        if (m && m.type === 'BROWSER_IP') { try { document.getElementById('ipOut').textContent = m.ok ? `browser ${m.ip || 'n/a'}` : `browser error: ${m.error}`; } catch {} }
      } catch {}
    }
    function wireWs(sock){
      try { sock.addEventListener('open', () => {
        wsReady = true;
        try { while (wsQueue.length) { sock.send(JSON.stringify(wsQueue.shift())); } } catch {}
      }); } catch {}
      try { sock.addEventListener('close', () => { wsReady = false; }); } catch {}
      try { sock.addEventListener('error', () => { wsReady = false; }); } catch {}
      try { sock.addEventListener('message', onWsMessage); } catch {}
    }
    function computeWsUrl(){
      if (backend.wsUrl) {
        const hasQuery = backend.wsUrl.includes('?');
        const param = backend.machineId ? `${hasQuery ? '&' : '?'}fly_machine=${encodeURIComponent(backend.machineId)}` : '';
        return `${backend.wsUrl}${param}`;
      }
      if (backend.directWs) {
        return backend.directWs;
      }
      if (backend.machineHost) {
        return backend.machineHost.replace(/^https:\/\//, 'wss://').replace(/^http:\/\//, 'ws://');
      }
      const fallback = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host;
      return backend.machineId ? `${fallback}?fly_machine=${encodeURIComponent(backend.machineId)}` : fallback;
    }

    function openWS(){
      try { if (ws) { try { ws.removeEventListener('message', onWsMessage); } catch {}; try { ws.close(); } catch {} } } catch {}
      wsReady = false;
      const target = computeWsUrl();
      log(`[ws] connect ${target}`);
      ws = new WebSocket(target);
      wireWs(ws);
    }
    function ensureWS(){ if (!ws || ws.readyState > 1) openWS(); }
    function send(obj){
      try {
        if (!ws || ws.readyState !== 1) {
          ensureWS();
          wsQueue.push(obj);
          return;
        }
        ws.send(JSON.stringify(obj));
      } catch (e) { log('WS send error: ' + (e.message||e)); }
    }
    ensureWS();

    function applyBackendConfig(cfg = {}) {
      backend.remoteEnabled = true;
      if (cfg.baseHttp) backend.baseHttp = String(cfg.baseHttp).replace(/\/$/, '') || backend.baseHttp;
      if (cfg.wsUrl) backend.wsUrl = String(cfg.wsUrl).trim() || backend.wsUrl;
      if (cfg.machineId) backend.machineId = cfg.machineId;
      if (cfg.machineHost !== undefined) backend.machineHost = cfg.machineHost || '';
      backend.directWs = cfg.directWs ? String(cfg.directWs).trim() : '';
      if (cfg.signaling !== undefined) backend.signaling = cfg.signaling || null;
      if (Array.isArray(cfg.ice)) backend.iceServers = cfg.ice;
      try {
        localStorage.setItem('remoteEnabled', 'true');
        localStorage.setItem('remoteHttp', backend.baseHttp);
        localStorage.setItem('remoteWs', backend.wsUrl);
        if (backend.machineId) localStorage.setItem('remoteMachineId', backend.machineId);
        if (backend.machineHost) localStorage.setItem('remoteMachineHost', backend.machineHost);
        if (backend.directWs) localStorage.setItem('remoteDirectWs', backend.directWs); else localStorage.removeItem('remoteDirectWs');
      } catch {}
      try { openWS(); } catch {}
    }

    function applySecrets(secrets = {}) {
      try {
        if (secrets.criticKey) localStorage.setItem('criticOpenaiKey', secrets.criticKey);
        if (secrets.retrieverKey) localStorage.setItem('retrieverOpenaiKey', secrets.retrieverKey);
        if (secrets.plannerKey) localStorage.setItem('plannerOpenaiKey', secrets.plannerKey);
        if (secrets.nanoKey) localStorage.setItem('openaiApiKey2', secrets.nanoKey);
        if (secrets.assistantId2) localStorage.setItem('assistantId2', secrets.assistantId2);
        if (secrets.criticModel) localStorage.setItem('criticModel', secrets.criticModel);
        if (secrets.plannerModel) localStorage.setItem('plannerModel', secrets.plannerModel);
        if (secrets.retrieverModel) localStorage.setItem('retrieverModel', secrets.retrieverModel);
      } catch {}
      try { const el = document.getElementById('openaiKey2'); if (el && secrets.nanoKey) el.value = secrets.nanoKey; } catch {}
      try { const el = document.getElementById('assistantId2'); if (el && secrets.assistantId2) el.value = secrets.assistantId2; } catch {}
    }

    function startAgentPrompt(prompt){
      const text = String(prompt || '').trim();
      const promptEl = document.getElementById('prompt');
      try { if (promptEl) promptEl.value = text; } catch {}
      if (!text) return;
      log(`[*] Auto-run with prompt: ${text}`);
      startRunWithPrompt(text);
    }

    window.__NEROVA_AGENT = {
      configureBackend: applyBackendConfig,
      setSecrets: applySecrets,
      start: startAgentPrompt,
      ready: true
    };

    function setUrlBar(u){ try { const el = document.getElementById('currentUrlLine'); if (el) el.value = String(u||''); } catch {} }

    // Persist creds
    const key2 = document.getElementById('openaiKey2');
    const asst2 = document.getElementById('assistantId2');
    key2.value = localStorage.getItem('openaiApiKey2') || '';
    asst2.value = localStorage.getItem('assistantId2') || '';
    document.getElementById('btnSave').onclick = () => {
      localStorage.setItem('openaiApiKey2', key2.value || '');
      localStorage.setItem('assistantId2', asst2.value || '');
      document.getElementById('saveMsg').textContent = 'Saved';
      setTimeout(()=> document.getElementById('saveMsg').textContent = '', 1000);
    };

    document.getElementById('btnFocus').onclick = () => send({ type: 'FOCUS' });
    document.getElementById('btnGo').onclick = () => {
      const u = document.getElementById('url').value.trim(); if (!u) return;
      send({ type: 'FOCUS' }); setTimeout(()=> send({ type:'NAVIGATE', url: u }), 50);
    };
    document.getElementById('btnCopyUrl').onclick = async () => {
      try { const el = document.getElementById('currentUrlLine'); el.select(); document.execCommand('copy'); } catch {}
    };
    document.getElementById('btnServerIp').onclick = () => { try { send({ type:'SERVER_IP' }); } catch {} };
    document.getElementById('btnBrowserIp').onclick = () => { try { send({ type:'BROWSER_IP' }); } catch {} };

    // Update URL bar from server events
    ws.addEventListener('message', (ev) => {
      try {
        const m = JSON.parse(ev.data);
        if (m && m.type === 'NAVIGATED' && typeof m.url === 'string') setUrlBar(m.url);
        if (m && m.type === 'URL' && typeof m.url === 'string') setUrlBar(m.url);
        if (m && m.type === 'SERVER_IP') { try { document.getElementById('ipOut').textContent = m.ok ? `server ${m.ip || 'n/a'} (${(m.env&&m.env.fly&&m.env.fly.region)||'?'})` : `server error: ${m.error}`; } catch {} }
        if (m && m.type === 'BROWSER_IP') { try { document.getElementById('ipOut').textContent = m.ok ? `browser ${m.ip || 'n/a'}` : `browser error: ${m.error}`; } catch {} }
      } catch {}
    });

    const criticInputEl = document.getElementById('criticInput');
    const criticOutputEl = document.getElementById('criticOutput');
    const step3El = document.getElementById('step3');
    const exactEl = document.getElementById('exact');
    const step4El = document.getElementById('step4');
    const step4TextEl = document.getElementById('step4Text');
    const verificationEl = document.getElementById('verification');
    const scrollsEl = document.getElementById('scrolls');

    let running = false;
    let paused = false;
    let loopTimer = null; // scheduled next loop; cleared on pause/stop
    const inflightFetchControllers = new Set(); // track in-flight API calls for abort
    // Context session (multi-step) state
    let contextActive = false;
    let contextPrompt = '';
    let contextStep = 0;
    const contextMaxSteps = 10;
    let currentTarget = null; // { hints, center?, content? }
    let lastAction = null;
    let actionHistory = [];
    let completeHistory = [];
    let bootstrapped = false;
    const promptEl = document.getElementById('prompt');

    // Minimal verifier injection like /interface
    async function ensureVerifier() {
      try {
        ensureWS();
        const ready = new Promise((resolve) => {
          const handler = (ev) => { try { const m = JSON.parse(ev.data); if (m && m.type === 'CLICK_VERIFIER_READY') { ws.removeEventListener('message', handler); resolve(true); } } catch {} };
          ws.addEventListener('message', handler);
          setTimeout(() => { ws.removeEventListener('message', handler); resolve(false); }, 1500);
        });
        send({ type: 'INJECT_CLICK_VERIFIER' });
        await ready;
      } catch { await new Promise(r => setTimeout(r, 150)); }
    }

    async function getCurrentUrl(){
      return await new Promise(resolve => {
        const handler = (ev) => { try { const m = JSON.parse(ev.data); if (m && m.type === 'URL') { ws.removeEventListener('message', handler); resolve(m.url || ''); } } catch {} };
        ws.addEventListener('message', handler);
        try { send({ type: 'GET_URL' }); } catch {}
        setTimeout(()=>{ ws.removeEventListener('message', handler); resolve(''); }, 1200);
      });
    }

    function norm(s){ return (s||'').toString(); }

    function setPaused(state, reason){
      try {
        paused = !!state;
        const btnCont = document.getElementById('btnContinue');
        const msg = document.getElementById('pauseMsg');
        if (btnCont) btnCont.disabled = true; // require context input to enable
        if (msg) msg.textContent = paused ? (reason || 'Paused. Add context and Continue.') : '';
        if (paused && loopTimer) { try { clearTimeout(loopTimer); } catch {} loopTimer = null; }
        if (paused) {
          try { for (const c of inflightFetchControllers) { try { c.abort(); } catch {} } } catch {}
          try { inflightFetchControllers.clear(); } catch {}
        }
      } catch {}
    }

    // Enable Continue only when paused AND context has content
    function updateContinueEnabled(){
      try {
        const btnCont = document.getElementById('btnContinue');
        const ctx = document.getElementById('contextNotes');
        if (!btnCont) return;
        const hasContext = !!(ctx && ctx.value && ctx.value.trim().length > 0);
        btnCont.disabled = !(paused && hasContext);
      } catch {}
    }

    function scheduleNext(delayMs){
      try {
        if (loopTimer) { clearTimeout(loopTimer); }
        loopTimer = setTimeout(() => {
          if (!running || paused) return;
          runLoop();
        }, Math.max(0, Number(delayMs)||0));
      } catch {}
    }

    async function runLoop(){
      if (!running) return;
      try {
        // Build critic prompt
        const basePrompt = document.getElementById('prompt').value || '';
        const currentUrl = await getCurrentUrl();
        setUrlBar(currentUrl || '');

        // One-time URL bootstrap: decide initial URL before the first real turn
        if (!bootstrapped) {
          const urlCriticSys = `SYSTEM (URL Bootstrap Critic)

You are the URL Bootstrap Critic. Decide the single best initial URL to open NOW to advance toward the final goal.

Rules:
- Output ONLY a single JSON object (no prose, no markdown, no code fences).
- Allowed actions (choose ONE): navigate | proceed | resend
- If action=navigate: url must be HTTPS, canonical/official page (no shorteners). Remove tracking query unless required.
- If action=proceed: current page is already correct to start the task.
- If action=resend: the page appears in transition/blank; the runtime will retry this same prompt with a fresh screenshot.
- Include a short reason and numeric confidence 0..1.
- REQUIRED: include top-level complete (array). Use [] if nothing was completed; otherwise include one concise string that reflects the outcome, e.g., "navigated to https://example.com" for navigate, or "proceed" for proceed.`;

          const body = {
            openaiApiKey: localStorage.getItem('criticOpenaiKey') || localStorage.getItem('retrieverOpenaiKey') || localStorage.getItem('plannerOpenaiKey') || '',
            model: localStorage.getItem('criticModel') || 'gpt-5',
            system: urlCriticSys,
            user: JSON.stringify({ goal: { original_prompt: basePrompt }, context: { current_url: currentUrl || '' } })
          };
          if (body.openaiApiKey) {
            try { criticInputEl.textContent = JSON.stringify({ system: urlCriticSys, user: JSON.parse(body.user) }, null, 2); } catch {}
            const acB = new AbortController(); inflightFetchControllers.add(acB);
            let rB;
            try {
            rB = await backendFetch('/critic', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body), signal: acB.signal });
            } catch (e) {
              inflightFetchControllers.delete(acB);
              if (paused) return;
              throw e;
            }
            inflightFetchControllers.delete(acB);
            const jB = await rB.json();
            if (paused) return;
            const decisionB = jB && (jB.parsed || jB);
            try { criticOutputEl.textContent = JSON.stringify(decisionB || {}, null, 2); } catch {}
            // Merge completes from bootstrap if provided (normalize legacy tokens)
            try {
              const arrB = (decisionB && Array.isArray(decisionB.complete)) ? decisionB.complete : (typeof decisionB?.complete === 'string' ? [decisionB.complete] : []);
              for (const s of arrB) {
                let v = String(s||'').trim(); if (!v) continue;
                if (v.startsWith('bootstrap_navigate:')) { v = 'navigated to ' + v.slice('bootstrap_navigate:'.length).trim(); }
                if (v === 'bootstrap_proceed') { v = 'proceed'; }
                const key = v.toLowerCase();
                if (!completeHistory.some(x => String(x||'').toLowerCase() === key)) completeHistory.push(v);
              }
              try { const ch = document.getElementById('completeHistory'); if (ch) ch.textContent = JSON.stringify(completeHistory.slice(-20), null, 2); } catch {}
            } catch {}
            if (decisionB && decisionB.action === 'navigate' && typeof decisionB.url === 'string' && decisionB.url.trim()) {
              send({ type: 'FOCUS' });
              send({ type: 'NAVIGATE', url: decisionB.url.trim() });
              bootstrapped = true;
              scheduleNext(800);
              return;
            }
            if (decisionB && decisionB.action === 'resend') {
              scheduleNext(250);
              return;
            }
            // proceed or anything else → mark bootstrapped and continue
            bootstrapped = true;
          } else {
            // No API key: skip bootstrap
            bootstrapped = true;
          }
        }
        const criticSys = `SYSTEM (Screen-first Web Action Critic)

You are a natural-language-to-web action critic. The goal is stated by the user prompt. Make the best single decision NOW, based ONLY on what is visible in the current screenshot, to advance toward the final goal.

Strict rules:
- Output ONLY a single valid JSON object (no prose, no markdown, no code fences).
 - Allowed actions: accept | click_by_text_role | scroll | back | navigate | resend | stop (choose ONE).
 - Use action="resend" ONLY if the intended/expected candidate is not visible in the screenshot and the page appears to be still loading or an initial blank/transition frame; on resend the runtime will immediately retry the same prompt with a fresh screenshot of the same viewport.
- Prefer deterministic visible signals: text + role.
- Never return "accept" unless the chosen control is visibly present.
- For action="scroll" include: scroll { direction: "down" | "up", pages?: 1..3 }.
- Include a non-empty reason and a numeric confidence 0..1.
 - Include what has been completed this step under a top-level "complete" array (use [] if none).

Context override (active only when goal.new_context is non-empty):
- Treat goal.new_context as a temporary subgoal that overrides the original prompt.
- Include keep: true|false (true = more steps needed to finish the subgoal; false = subgoal finished). Do not return stop while new_context is active.

Universal schema (ALL ACTIONS):
- Required fields: action (string), reason (string), confidence (number), continue (boolean).
- Optional depending on action:
  - target (for click_by_text_role)
  - scroll { direction:"down"|"up", pages?:1..3 } (for scroll)
  - url (for navigate)
  - content (for typing after focus)
  - clear (boolean; delete all pre-existing text before typing)


Examples (non-click actions include continue):
{ "action":"scroll", "scroll": { "direction":"down", "pages":1 }, "reason":"…", "confidence":0.7, "continue": true }
{ "action":"back", "reason":"…", "confidence":0.6, "continue": true }
{ "action":"navigate", "url":"https://example.com/cart", "reason":"…", "confidence":0.8, "continue": true }

Output format for click actions (REQUIRED):
- Return exactly: { "action": "click_by_text_role", "target": { "id": "Step 2", "type": "click_by_candidates", "center": [vx, vy], "hints": { "text_exact": string[], "roles": string[], "text": string[] }, "content": optional string, "clear": optional boolean }, "reason": "…", "confidence": 0.0, "continue": true }
- target.center MUST be present (CSS viewport pixels).
- Use arrays for hints; do NOT use singular fields like "role" or a single "text_exact" string. If none, use empty arrays.
- Do NOT return type_in_text_role. If typing is needed after focusing an input, include "content".
 - If the intent requires replacing pre-existing text in an input, set target.clear=true (meaning: delete all text in the focused input before typing), then include the desired "content".

Objective:
- Make the best single decision in the current situation to advance toward the final goal from the user prompt.

Screen-first precedence:
- Always prioritize what is visible on the current screen.

Visual-first decision policy:
- Decide only from the screenshot (no hidden assumptions).
- If a visible control more directly advances the end goal, return click_by_text_role and include a full Step-2 replacement target with text_exact first (then fallbacks).
- Prefer direct on-screen goal-aligned controls over indirect paths. Only type/search when the needed entity/control is not visible.
- If nothing clearly aligns, return scroll (direction/pages). Do not click unrelated CTAs.
- When the page is a different variant than expected, pick the visible entry point whose text best matches the goal keywords.
- Never choose controls whose text contradicts the goal keywords.

Visibility constraint (MUST SEE ON SCREEN):
- Only return click_by_text_role when the replacement target is fully visible in the screenshot (not offscreen, not clipped, not clearly occluded).
- Edge-centering rule: If the chosen target is near the top/bottom edges (≈ <90px from top OR ≈ <120px from bottom), first return action="scroll" with scroll { direction: "up" or "down", pages: 1 }, keep the same target, then decide again.

Full-page scan discipline:
- Scan the ENTIRE screenshot (top, middle, bottom) before deciding; do not anchor on one region.
- Do NOT default to search if a goal-aligned entity/control is visible anywhere on screen.

Popup awareness:
- Detect blocking overlays/modals/popups/banners (e.g., cookie consent, newsletter modal, full-screen dialog). If they block the intended action, first dismiss/close them using click_by_text_role on visible controls like “Close”, “×”, “No thanks”, “Accept”. If non-blocking, ignore and proceed with the primary goal.

Navigation optimization:
- Prefer the most direct, on-screen link/button toward the goal (e.g., a deep link to the target page/tile) over generic home/dashboard links. If a deep link is visible and relevant, choose it now.
- If a chosen deep link fails to load correctly on the next turn (e.g., unexpected page or error), then fall back to a safer, more general navigation link.

Complete history awareness:
- You will receive recent complete_history (ordered). Treat each entry as DONE. Do not attempt to redo or re-verify them unless the page clearly reset.
- When choosing the next action, advance the next unmet milestone implied by the goal and complete_history. If complete_history contains a matching milestone (e.g., variant selected), prefer the next step (e.g., Add to cart) over re-selecting variants.

Stuck handling:
- If recent decisions have not produced any new "complete" items (no visible progress), change strategy immediately.
- Try a different viable on-screen control, reverse scroll direction, use back, or navigate to a better entry point. Do not loop re-checking the same milestone.

Goal-first rule:
- Choose the single action that most directly advances the prompt’s end goal NOW; avoid redundant actions (e.g., do not search for something already visible to click).`;

        const plannedStep = (currentTarget && currentTarget.hints) ? {
          id: currentTarget.id || 'Step 2', type: 'click_by_candidates', hints: currentTarget.hints || {}, content: (currentTarget.content || '')
        } : { id:'Step 2', type:'click_by_candidates', hints:{}, content:'' };

        // Ensure page is fully loaded/stable before taking the critic screenshot
        await new Promise((resolve) => {
          let done = false;
          const finish = () => { if (done) return; done = true; resolve(true); };
          const handler = (ev) => { try { const m = JSON.parse(ev.data); if (m && m.type === 'LOADED') { ws.removeEventListener('message', handler); finish(); } } catch {} };
          ws.addEventListener('message', handler);
          try { ws.send(JSON.stringify({ type: 'WAIT_FOR_LOAD' })); } catch {}
          setTimeout(() => { ws.removeEventListener('message', handler); finish(); }, 3000);
        });

        const userPayload = {
          goal: {
            original_prompt: basePrompt,
            new_context: (contextActive ? contextPrompt : '')
          },
          context: { current_url: currentUrl, context_active: !!contextActive, context_step: (contextActive ? contextStep : 0) },
          plan_window: { planned_step: plannedStep, next_steps: [] },
          complete_history: completeHistory.slice(-20)
        };
        const includedContext = !!contextActive;
        const body = {
          openaiApiKey: localStorage.getItem('criticOpenaiKey') || localStorage.getItem('retrieverOpenaiKey') || localStorage.getItem('plannerOpenaiKey') || '',
          model: localStorage.getItem('criticModel') || 'gpt-5',
          system: criticSys,
          user: JSON.stringify(userPayload)
        };
        const ci = { system: criticSys, user: JSON.parse(body.user) };
        criticInputEl.textContent = JSON.stringify(ci, null, 2);
        try { bc && bc.postMessage({ type:'CRITIC_INPUT', payload: ci }); } catch {}
        // Abortable fetch for /critic
        const ac = new AbortController(); inflightFetchControllers.add(ac);
        let j;
        try {
          if (signalingUrl && signalToken) {
            try {
              const resp = await signalRequest('POST', '/critic', body, { 'Content-Type': 'application/json' });
              j = resp && resp.body ? resp.body : null;
            } catch (err) {
              log('[signal] critic error: ' + (err && err.message || err));
              throw err;
            }
          } else {
            const r = await backendFetch('/critic', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body), signal: ac.signal });
            j = await r.json();
          }
        } catch (e) {
          inflightFetchControllers.delete(ac);
          if (paused) return; // ignore aborted during pause
          throw e;
        }
        inflightFetchControllers.delete(ac);
        // If paused mid-response, ignore it (prevents mixed outputs)
        if (paused) return;
        let decision = j && (j.parsed || j);
        criticOutputEl.textContent = JSON.stringify(decision || {}, null, 2);
        try { bc && bc.postMessage({ type:'CRITIC_OUTPUT', payload: decision||{} }); } catch {}
        try { const img = document.getElementById('criticShot'); if (img && j && typeof j.screenshot==='string') img.src = j.screenshot; } catch {}
        try { bc && bc.postMessage({ type:'SCREENSHOT', payload: j && j.screenshot ? j.screenshot : null }); } catch {}
        // Enforce presence of top-level complete: retry once if omitted
        if (decision && typeof decision === 'object' && !('complete' in decision)) {
          try {
            const criticSys2 = criticSys + "\n\nSchema enforcement: The top-level field 'complete' is REQUIRED in every response. If no new items, set it to []. Do not omit.";
            const r2 = await backendFetch('/critic', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ ...body, system: criticSys2 }) });
            const j2 = await r2.json();
            const d2 = j2 && (j2.parsed || j2);
            if (d2 && typeof d2 === 'object') { decision = d2; criticOutputEl.textContent = JSON.stringify(decision || {}, null, 2); }
          } catch {}
        }
        if (decision && typeof decision === 'object' && !('complete' in decision)) {
          try { decision.complete = []; criticOutputEl.textContent = JSON.stringify(decision || {}, null, 2); } catch {}
        }
        // Merge completes into completeHistory (dedup, case-insensitive)
        try {
          const arr = (decision && Array.isArray(decision.complete)) ? decision.complete : (typeof decision?.complete === 'string' ? [decision.complete] : []);
          for (const s of arr) {
            const v = String(s||'').trim(); if (!v) continue;
            const key = v.toLowerCase();
            if (!completeHistory.some(x => String(x||'').toLowerCase() === key)) completeHistory.push(v);
          }
          try { const ch = document.getElementById('completeHistory'); if (ch) ch.textContent = JSON.stringify(completeHistory.slice(-20), null, 2); } catch {}
          try { bc && bc.postMessage({ type:'COMPLETE_HISTORY', payload: completeHistory.slice(-20) }); } catch {}
        } catch {}

        if (!decision || !decision.action) { log('[agent] no-action'); return; }
        log(`[agent] action=${decision.action}`);
        if (decision.action === 'resend') {
          // Immediately retry with a fresh screenshot and identical prompt
          scheduleNext(250);
          return;
        }
        // Handle multi-step context: read optional keep flag
        try {
          if (includedContext) {
            const keep = (decision && Object.prototype.hasOwnProperty.call(decision, 'keep')) ? !!decision.keep : null;
            if (keep === true && contextStep < contextMaxSteps) {
              contextStep += 1;
            } else {
              contextActive = false;
              contextPrompt = '';
              contextStep = 0;
            }
          }
        } catch {}
        if (decision.action === 'navigate' && decision.url) {
          log(`[agent] navigate ${decision.url}`);
          send({ type: 'FOCUS' });
          send({ type: 'NAVIGATE', url: decision.url });
          try { actionHistory.push({ t: Date.now(), action: 'navigate', url: decision.url }); } catch {}
          scheduleNext(1200);
          return;
        }
        if (decision.action === 'scroll') {
          const dir = (decision.scroll && (decision.scroll.direction === 'up' || decision.scroll.direction === 'down')) ? decision.scroll.direction : 'down';
          log(`[agent] scroll ${dir}`);
          send({ type:'FOCUS' });
          send({ type:'SCROLL_UNIVERSAL', direction: dir });
          try { scrollsEl.textContent = JSON.stringify({ direction: dir }, null, 2); } catch {}
          try { actionHistory.push({ t: Date.now(), action: 'scroll', direction: dir }); } catch {}
          scheduleNext(800);
          return;
        }
        if (decision.action === 'click_by_text_role' && decision.target) {
          log(`[agent] click ${decision.target?.hints?.text_exact?.[0] || ''}`);
          const hints = (decision.target.hints || {});
          const center = (Array.isArray(decision.target.center) && decision.target.center.length===2) ? decision.target.center : null;
          currentTarget = { id: decision.target.id||'Step 2', hints, center, content: (decision.target.content || ''), clear: (decision.target && decision.target.clear === true) };
          // Radius candidates: request STEP3-like elements by ids (we don't have direct API, so reuse: GRAB_HITTABLES + filter client-side)
          // We'll fetch a broad set of hittables via GRAB_HITTABLES (server path) is not available; use candidates string set instead.
          // Instead, call existing small-grab: GET_HITTABLES_BY_IDS path requires ids; fallback to a local candidates scan:
          // We will ask for GRAB_CANDIDATE_STRINGS to get ids, then fetch full hittables by ids and apply radius filtering.
          // Simpler: we already have a STEP3 handler in main UI; here we implement a minimal client-side radius filter workflow via a custom message cycle.

          // Request a full STEP3 dump (deduped like /interface) then radius-filter client-side
          // Stabilize then request STEP3
          await new Promise((resolve)=>{ const h=(ev)=>{ try{ const m=JSON.parse(ev.data); if(m&&m.type==='LOADED'){ ws.removeEventListener('message',h); resolve(true);} }catch{} }; ws.addEventListener('message',h); try{ send({ type:'WAIT_FOR_LOAD' }); }catch{} setTimeout(()=>{ ws.removeEventListener('message',h); resolve(false); }, 1200); });
          if (center) {
            try { send({ type:'DRAW_RADIUS', vx: center[0], vy: center[1], r: 120, color: '#0ff' }); } catch {}
          }
          let elements = await new Promise(resolve => {
            const handler = (ev) => { try { const m = JSON.parse(ev.data); if (m && m.type==='STEP3' && Array.isArray(m.elements)) { ws.removeEventListener('message', handler); resolve(m.elements); } } catch {} };
            ws.addEventListener('message', handler);
            try { send({ type: 'GET_HITTABLES_VIEWPORT', options: { minSize: 8, max: 2000 } }); } catch {}
            setTimeout(()=>{ ws.removeEventListener('message', handler); resolve([]); }, 4000);
          });
          if (!Array.isArray(elements) || elements.length===0) {
            // Retry once after a short settle
            await new Promise(r=>setTimeout(r, 300));
            elements = await new Promise(resolve => {
              const handler = (ev) => { try { const m = JSON.parse(ev.data); if (m && m.type==='STEP3' && Array.isArray(m.elements)) { ws.removeEventListener('message', handler); resolve(m.elements); } } catch {} };
              ws.addEventListener('message', handler);
              try { send({ type: 'GET_HITTABLES_VIEWPORT', options: { minSize: 8, max: 2000 } }); } catch {}
              setTimeout(()=>{ ws.removeEventListener('message', handler); resolve([]); }, 4000);
            });
          }
          // Radius filter with rect proximity (include centers near point OR rect edge within R)
          let pool = Array.isArray(elements) ? elements : [];
          if (center) {
            const [cx, cy] = center; const R = 120;
            function within(e){
              try {
                if (Array.isArray(e.center) && e.center.length===2) {
                  const d = Math.hypot(e.center[0]-cx, e.center[1]-cy);
                  if (d <= R) return true;
                }
                const r = Array.isArray(e.rect) ? e.rect : [0,0,0,0];
                const left=r[0], top=r[1], right=left+(r[2]||0), bottom=top+(r[3]||0);
                // If point inside rect
                if (cx>=left && cx<=right && cy>=top && cy<=bottom) return true;
                // Distance from point to rect edges
                const dx = (cx < left) ? (left - cx) : (cx > right ? cx - right : 0);
                const dy = (cy < top) ? (top - cy) : (cy > bottom ? cy - bottom : 0);
                return Math.hypot(dx, dy) <= R;
              } catch { return false; }
            }
            let filtered = pool.filter(within);
            // Fallback: if none, take nearest 20 by distance to rect/center
            if (filtered.length === 0) {
              function dist(e){
                try {
                  const rc = Array.isArray(e.center) && e.center.length===2 ? Math.hypot(e.center[0]-cx, e.center[1]-cy) : Infinity;
                  const r = Array.isArray(e.rect) ? e.rect : [0,0,0,0];
                  const left=r[0], top=r[1], right=left+(r[2]||0), bottom=top+(r[3]||0);
                  const dx = (cx < left) ? (left - cx) : (cx > right ? cx - right : 0);
                  const dy = (cy < top) ? (top - cy) : (cy > bottom ? cy - bottom : 0);
                  const dr = Math.hypot(dx, dy);
                  return Math.min(rc, dr);
                } catch { return Infinity; }
              }
              pool = pool.slice().sort((a,b)=>dist(a)-dist(b)).slice(0,20);
            } else {
              pool = filtered;
            }
          }
          // Build sets for exact matching; do not pre-filter by role here
          const exactSet = new Set(Array.isArray(hints.text_exact) ? hints.text_exact.map(s => (s||'').toString()) : []);
          // Build exact matches without dropping occluded; prefer hittable when clicking
          const exactMatchesAll = pool.filter(e => exactSet.has((e.name||'').toString()));
          const exactMatchesHittable = exactMatchesAll.filter(e => (e.hit_state||'') === 'hittable');
          const exactMatches = exactMatchesHittable.length ? exactMatchesHittable : exactMatchesAll;
          step3El.textContent = JSON.stringify({ center, radius: 120, pool: pool.slice(0,10), exactMatches: exactMatches.slice(0,10) }, null, 2);
          if (exactMatches.length >= 1) {
            // choose nearest to center if present
            let pick = exactMatches[0];
            if (center) {
              let bestD = Infinity; for (const e of exactMatches){ const d = Math.hypot(e.center[0]-center[0], e.center[1]-center[1]); if (d<bestD){ bestD=d; pick=e; } }
            }
            // Only click when actually hittable; if occluded, surface and continue loop
            if ((pick.hit_state||'') !== 'hittable') {
              try { exactEl.textContent = JSON.stringify({ exact: true, hittable: false, name: pick.name||'' }, null, 2); } catch {}
              scheduleNext(600);
              return;
            }
            send({ type:'FOCUS' });
            await new Promise(r=>setTimeout(r,80));
            await new Promise(async (resolve)=>{ try{ const clickTs=Date.now(); send({ type:'CLICK_VIEWPORT', vx: pick.center[0], vy: pick.center[1] }); resolve(true);}catch{resolve(false);} });
            try { exactEl.textContent = JSON.stringify({ exact: true, name: pick.name||'' }, null, 2); } catch {}
            // Type content if present
            const content = (currentTarget && typeof currentTarget.content==='string') ? currentTarget.content : '';
            const needClear = !!(currentTarget && currentTarget.clear === true);
            if (content) {
              // Stabilize focus after click to avoid missing the first character
              await new Promise(r=>setTimeout(r,160));
              try { send({ type:'FOCUS' }); } catch {}
              await new Promise(r=>setTimeout(r,80));
              // Re-click once to ensure caret in input (post-threshold)
              try { send({ type:'CLICK_VIEWPORT', vx: pick.center[0], vy: pick.center[1] }); } catch {}
              await new Promise(r=>setTimeout(r,80));
              if (needClear) {
                const clearToken = `clr-${Date.now().toString(36)}`;
                await new Promise((resolve)=>{ const h=(ev)=>{ try{ const m=JSON.parse(ev.data); if(m&&m.type==='CLEARED'&&(!m.token||m.token===clearToken)){ ws.removeEventListener('message',h); resolve(true);} }catch{} }; ws.addEventListener('message',h); send({ type:'CLEAR_ACTIVE_INPUT', token: clearToken }); setTimeout(()=>{ ws.removeEventListener('message',h); resolve(false);},2000); });
                await new Promise(r=>setTimeout(r,60));
              }
              const token = `typed-${Date.now().toString(36)}`;
              await new Promise((resolve)=>{ const h=(ev)=>{ try{ const m=JSON.parse(ev.data); if(m&&m.type==='TYPED'&&(!m.token||m.token===token)){ ws.removeEventListener('message',h); resolve(true);} }catch{} }; ws.addEventListener('message',h); send({ type:'TYPE_TEXT', text: content, delay: 120, token }); setTimeout(()=>{ ws.removeEventListener('message',h); resolve(false);},4000); });
              try { send({ type:'PRESS_ENTER' }); } catch {}
              try { actionHistory.push({ t: Date.now(), action: 'type', content }); } catch {}
            }
            try { actionHistory.push({ t: Date.now(), action: 'click', name: pick.name||'', role: pick.role||'' }); } catch {}
            scheduleNext(800);
            return;
          } else {
            // Escalate to nano (Assistant 2) with small pool (<=10)
            const openaiApiKey2 = localStorage.getItem('openaiApiKey2') || '';
            const assistantId2 = localStorage.getItem('assistantId2') || '';
            if (!openaiApiKey2 || !assistantId2) { log('Nano missing; cannot escalate.'); scheduleNext(800); return; }
            const small = pool.slice(0, 10);
            const payload = currentTarget ? { target: currentTarget, elements: small, openaiApiKey: openaiApiKey2, assistantId: assistantId2 } : { prompt: basePrompt, elements: small, openaiApiKey: openaiApiKey2, assistantId: assistantId2 };
            // Abortable fetch for /nl2web2 as well
            const ac2 = new AbortController(); inflightFetchControllers.add(ac2);
            let json;
            try {
              if (signalingUrl && signalToken) {
                try {
                  const resp = await signalRequest('POST', '/nl2web2', payload, { 'Content-Type': 'application/json' });
                  json = resp && resp.body ? resp.body : null;
                } catch (err) {
                  log('[signal] nl2web2 error: ' + (err && err.message || err));
                  throw err;
                }
              } else {
                const r2 = await backendFetch('/nl2web2', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload), signal: ac2.signal });
                json = await r2.json();
              }
            } catch (e) {
              inflightFetchControllers.delete(ac2);
              if (paused) { scheduleNext(800); return; }
              throw e;
            }
            inflightFetchControllers.delete(ac2);
            // Match /interface: prefer parsed, else parse raw text, else fallback
            let step4 = null;
            if (json && typeof json === 'object') {
              if (json.parsed) {
                step4 = json.parsed;
              } else if (typeof json.raw === 'string') {
                let s = json.raw.trim();
                if (s.startsWith('```')) { s = s.replace(/```[a-zA-Z]*\n?/g, '').replace(/```/g, '').trim(); }
                const m = s.match(/\{[\s\S]*\}/);
                if (m) { try { step4 = JSON.parse(m[0]); } catch { /* ignore */ } }
                if (!step4) step4 = s;
              } else {
                step4 = json;
              }
            }
            try { step4El.textContent = typeof step4 === 'string' ? step4 : JSON.stringify(step4, null, 2); step4TextEl.textContent = (step4 && typeof step4==='object' && typeof step4.content==='string') ? step4.content : ''; } catch {}
            // If confident and has center, click with verification like /interface
            if (step4 && typeof step4==='object' && typeof step4.confidence === 'number' && step4.confidence >= 0.8 && Array.isArray(step4.center) && step4.center.length===2) {
              try { await (async () => { try { await ensureVerifier(); } catch {} })(); } catch {}
              send({ type:'FOCUS' }); await new Promise(r=>setTimeout(r,80));
              const clickTs2 = Date.now(); send({ type:'CLICK_VIEWPORT', vx: step4.center[0], vy: step4.center[1] });
              // Lightweight verification: if href present, poll URL, else fetch last click chain
              try {
                if (step4 && typeof step4.href === 'string' && step4.href) {
                  const beforeUrl = await getCurrentUrl();
                  const resolveAbsoluteUrl = (href, base) => { try { return new URL(href, base).toString(); } catch { return ''; } };
                  const normalizeHost = (host) => { host = (host||'').toLowerCase(); if (host.startsWith('www.')) host = host.slice(4); return host; };
                  const normalizePath = (path) => { if (!path) return '/'; let p = path.replace(/\+/g,'/'); if (!p.startsWith('/')) p = '/' + p; if (p.length > 1 && p.endsWith('/')) p = p.slice(0, -1); return p; };
                  const firstPathPrefix = (path, maxSegments = 2) => { const parts = normalizePath(path).split('/').filter(Boolean); const take = Math.min(parts.length, Math.max(1, maxSegments)); return '/' + parts.slice(0, take).join('/'); };
                  const expectedAbs = resolveAbsoluteUrl(String(step4.href||''), beforeUrl || location.href);
                  let expected; try { expected = new URL(expectedAbs); } catch { expected = null; }
                  if (expected) {
                    const expectedHost = normalizeHost(expected.host);
                    const expectedPrefix = firstPathPrefix(expected.pathname, 2);
                    let beforeHost = ''; try { beforeHost = normalizeHost(new URL(beforeUrl || location.href).host); } catch {}
                    const crossDomain = !!beforeHost && expectedHost !== beforeHost;
                    const start = Date.now();
                    while (Date.now() - start < 8000) {
                      const now = await getCurrentUrl();
                      try {
                        const u = new URL(now||'');
                        const actualHost = normalizeHost(u.host);
                        const actualPath = normalizePath(u.pathname);
                        const hostOk = actualHost === expectedHost;
                        const pathOk = actualPath.startsWith(expectedPrefix);
                        if ((crossDomain && hostOk) || (!crossDomain && hostOk && pathOk)) break;
                      } catch {}
                      await new Promise(r=>setTimeout(r, 300));
                    }
                  }
                } else {
                  await new Promise((resolve)=>{
                    const to = setTimeout(()=> resolve(false), 1200);
                    const h=(ev)=>{ try{ const m=JSON.parse(ev.data); if(m&&m.type==='CLICK_CHAIN'){ ws.removeEventListener('message',h); clearTimeout(to); resolve(true); } }catch{} };
                    ws.addEventListener('message',h);
                    try { send({ type:'GET_LAST_CLICK_CHAIN' }); } catch {}
                  });
                }
              } catch {}
              const content = (currentTarget && typeof currentTarget.content==='string') ? currentTarget.content : '';
              const needClear = !!(currentTarget && currentTarget.clear === true);
              if (content) {
                // Stabilize focus after click to avoid missing the first character
                await new Promise(r=>setTimeout(r,160));
                try { send({ type:'FOCUS' }); } catch {}
                await new Promise(r=>setTimeout(r,80));
                // Re-click once to ensure caret in input (post-threshold)
                try { send({ type:'CLICK_VIEWPORT', vx: step4.center[0], vy: step4.center[1] }); } catch {}
                await new Promise(r=>setTimeout(r,80));
                if (needClear) {
                  const clearToken = `clr-${Date.now().toString(36)}`;
                  await new Promise((resolve)=>{ const h=(ev)=>{ try{ const m=JSON.parse(ev.data); if(m&&m.type==='CLEARED'&&(!m.token||m.token===clearToken)){ ws.removeEventListener('message',h); resolve(true);} }catch{} }; ws.addEventListener('message',h); send({ type:'CLEAR_ACTIVE_INPUT', token: clearToken }); setTimeout(()=>{ ws.removeEventListener('message',h); resolve(false);},2000); });
                  await new Promise(r=>setTimeout(r,60));
                }
                const token = `typed-${Date.now().toString(36)}`;
                await new Promise((resolve)=>{ const h=(ev)=>{ try{ const m=JSON.parse(ev.data); if(m&&m.type==='TYPED'&&(!m.token||m.token===token)){ ws.removeEventListener('message',h); resolve(true);} }catch{} }; ws.addEventListener('message',h); send({ type:'TYPE_TEXT', text: content, delay: 120, token }); setTimeout(()=>{ ws.removeEventListener('message',h); resolve(false);},4000); });
                try { send({ type:'PRESS_ENTER' }); } catch {}
                try { actionHistory.push({ t: Date.now(), action: 'type', content }); } catch {}
              }
              lastAction = { action: (content ? 'click_and_type':'click'), target: { id: step4.id||null, name: step4.name||'', role: step4.role||'' }, content: content||'' };
              try { actionHistory.push({ t: Date.now(), action: 'click', id: step4.id||null, name: step4.name||'', role: step4.role||'' }); } catch {}
              scheduleNext(800);
              return;
            }
            scheduleNext(800);
            return;
          }
        }
        if (decision.action === 'back') { history.back(); try { actionHistory.push({ t: Date.now(), action: 'back' }); } catch {} scheduleNext(800); return; }
        if (decision.action === 'stop') {
          running = false;
          setPaused(true, 'Paused (model requested STOP). Add context and Continue.');
          return;
        }
      } catch(e){ log('Loop error: '+(e.message||e)); }
    }

    // Helpers to drive run from external UI (/ui)
    function startRunWithPrompt(p){
      try { if (promptEl) promptEl.value = String(p||''); } catch {}
      if (running) return;
      ensureWS();
      running = true; paused = false; setPaused(false);
      contextActive = false; contextPrompt = ''; contextStep = 0;
      bootstrapped = false; // force URL bootstrap turn
      scheduleNext(150);
    }
    function pauseRun(){ running = false; setPaused(true); }
    function continueWithContext(text){
      const ctxVal = String(text||'').trim(); if (!ctxVal) return;
      contextActive = true; contextPrompt = ctxVal; contextStep = 0;
      setPaused(false); running = true; scheduleNext(150);
    }

    // Listen to control events from /ui
    try {
      bc && bc.addEventListener('message', (ev) => {
        const m = ev.data || {}; if (!m || !m.type) return;
        if (m.type === 'REMOTE_BACKEND' && m.http && m.ws) {
          try {
            backend.remoteEnabled = true;
            backend.baseHttp = String(m.http || '').replace(/\/$/, '') || backend.baseHttp;
            backend.wsUrl = String(m.ws || '').trim() || backend.wsUrl;
            backend.machineId = m.machineId || backend.machineId || '';
            backend.machineHost = m.machineHost || backend.machineHost || '';
            backend.directWs = m.directWs ? String(m.directWs).trim() : '';
            backend.signaling = m.signaling || null;
            backend.iceServers = m.ice || null;
            try {
              localStorage.setItem('remoteEnabled', 'true');
              localStorage.setItem('remoteHttp', backend.baseHttp);
              localStorage.setItem('remoteWs', backend.wsUrl);
              if (backend.machineId) localStorage.setItem('remoteMachineId', backend.machineId);
              if (backend.machineHost) localStorage.setItem('remoteMachineHost', backend.machineHost);
              if (backend.directWs) localStorage.setItem('remoteDirectWs', backend.directWs); else localStorage.removeItem('remoteDirectWs');
              if (backend.signaling) localStorage.setItem('remoteSignaling', JSON.stringify(backend.signaling));
              if (backend.iceServers) localStorage.setItem('remoteIceServers', JSON.stringify(backend.iceServers));
            } catch {}
            if (backend.signaling) {
              signalingUrl = backend.signaling.url || signalingUrl;
              signalToken = backend.signaling.token || signalToken;
            }
            openWS();
          } catch {}
          return;
        }
        if (m.type === 'START_RUN') {
          log(`[agent] start-run prompt="${(m.prompt||'').replace(/`/g,'') }", streamReady=${!!m.streamReady}`);
          if (m.prompt) startRunWithPrompt(m.prompt);
          return;
        }
        if (m.type === 'PAUSE') { pauseRun(); }
        if (m.type === 'CONTEXT_CONTINUE' && m.context) { continueWithContext(m.context); }
      });
    } catch {}

    document.getElementById('btnRun').onclick = async () => {
      if (running) return;
      // Start a fresh run regardless of previous pause state
      running = true;
      paused = false;
      setPaused(false);
      contextActive = false;
      contextPrompt = '';
      contextStep = 0;
      lastAction = null;
      currentTarget = null;
      send({ type: 'FOCUS' });
      scheduleNext(150);
    };

    // Pause/Continue controls
    document.getElementById('btnPause').onclick = () => {
      if (!paused) {
        running = false;
        setPaused(true, 'Paused by user. You can add context or manually operate the browser.');
        updateContinueEnabled();
      }
    };
    document.getElementById('btnContinue').onclick = () => {
      if (paused) {
        // Start a context session from the entered text
        const ctx = document.getElementById('contextNotes');
        if (!ctx || !ctx.value || !ctx.value.trim()) { setPaused(true, 'Please add context to continue.'); updateContinueEnabled(); return; }
        const ctxVal = ctx.value.trim();
        contextActive = true;
        contextPrompt = ctxVal;
        contextStep = 0;
        ctx.value = '';
        setPaused(false);
        running = true;
        // Optionally bring browser to front before continuing
        try { send({ type: 'FOCUS' }); } catch {}
        scheduleNext(150);
      }
    };
    document.getElementById('btnClearContext').onclick = () => {
      try { const el = document.getElementById('contextNotes'); if (el) el.value = ''; } catch {}
      updateContinueEnabled();
    };

    // Context input listener
    try { document.getElementById('contextNotes').addEventListener('input', updateContinueEnabled); } catch {}
  </script>
</body>
</html>
